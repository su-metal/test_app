# 現在のデータベース構成（Supabase）

> プロジェクト: アプリ作成 / 環境: 開発（Anon Key, RLS: 開発用全許可）
> 日付: 2025-10-10（JST）

---

## 1) テーブル概要

### products（商品）
- **確認済みの列**（ログ・実装より）
  - `id` **uuid** (PK)
  - `store_id` **uuid** (NOT NULL)
  - `name` **text**
  - `price` **numeric**
  - `stock` **integer**
  - `updated_at` **timestamptz**
- **存在しない列（ログで 400 を確認）**
  - `image_url` は **存在しない**（Select での 400: `column products.image_url does not exist`）
- **推奨インデックス**
  - `create index if not exists idx_products_store_id on public.products(store_id);`
  - `create index if not exists idx_products_store_id_stock on public.products(store_id, stock);`

---

### orders（注文）
- **確認済みの列/仕様**（実装・運用より）
  - `id` **uuid** (PK)
  - `store_id` **uuid** (NOT NULL)
  - `code` **text**  … ユーザー側の **6桁コード**（"000123" 形式）※UIは**完全一致**で照合
  - `customer` **text**  … メール等
  - `items` **jsonb**  … `[{ id, name, qty, price }]`
  - `total` **numeric**  … 合計（数値）
  - `placed_at` **timestamptz**  … 注文時刻（DB `DEFAULT now()` を**推奨**）
  - `status` **text**  … 実運用は `PENDING` / `FULFILLED`（UIでは `FULFILLED → redeemed` として表示）
- **推奨インデックス**
  - `create index if not exists idx_orders_store_id on public.orders(store_id);`
  - `create index if not exists idx_orders_status on public.orders(status);`
  - `create index if not exists idx_orders_code on public.orders(code);`

> 注: `status` は Supabase UI で **PENDING / FULFILLED** の選択肢が見える状態。`REDEEMED` はDB上の値としては**不要**（UI側が FULFILLED を redeemed と扱う）。

---

## 2) 代表的なDDL（現状整合 & 推奨を併記）

```sql
-- products（既存）
create table if not exists public.products (
  id uuid primary key default gen_random_uuid(),
  store_id uuid not null,
  name text,
  price numeric,
  stock integer,
  updated_at timestamptz default now()
);

-- orders（既存＋推奨DEFAULT）
create table if not exists public.orders (
  id uuid primary key default gen_random_uuid(),
  store_id uuid not null,
  code text,                 -- 6桁の文字列（例 "012345"）
  customer text,
  items jsonb,               -- [{id,name,qty,price}]
  total numeric,
  placed_at timestamptz default now(),  -- ★推奨: DEFAULT now()
  status text                 -- 運用: PENDING / FULFILLED
);

-- 参考: status を厳格化したい場合（任意）
-- alter table public.orders
--   add constraint orders_status_chk check (status in ('PENDING','FULFILLED'));
```

---

## 3) RLS（Row Level Security）

開発中は **全許可**で運用中。

```sql
alter table public.products enable row level security;
alter table public.orders   enable row level security;

-- products: 開発用
create policy if not exists "dev all products" on public.products
for all using (true) with check (true);

-- orders: 開発用（select / insert / update / delete）
create policy if not exists "dev select orders" on public.orders  for select using (true);
create policy if not exists "dev insert orders" on public.orders  for insert with check (true);
create policy if not exists "dev update orders" on public.orders  for update using (true) with check (true);
create policy if not exists "dev delete orders" on public.orders  for delete using (true);
```

> 本番では `store_id` や認証クレームでスコープを絞ること（例: `store_id = auth.jwt() ->> 'store_id'`）。

---

## 4) Realtime（購読）

- 対象: `public.orders`
- イベント: **UPDATE（必須）**, INSERT（任意）
- RLSの **SELECT ポリシーが必要**（SELECT不可だとUPDATE通知も届かない）
- ユーザーアプリ:
  - `status` が `FULFILLED` に更新されたUPDATEを受け取り、ローカル `orders` の該当行を `redeemed` に更新
  - 照合キーは **`code` の6桁完全一致**（一致しない場合のみ `id` で保険）
  - UI は `code6` 完全一致で重複除去し、`redeemed` を優先

---

## 5) データ整合の運用要点

- **orders.code** は **6桁の数字文字列**で統一（先頭ゼロ保持）。
  - 既存データに数値（ゼロ欠落）がある場合は一度だけ正規化:
    ```sql
    alter table public.orders alter column code type text using code::text;
    update public.orders
      set code = lpad(regexp_replace(code, '\\D', '', 'g'), 6, '0')
      where code ~ '^\d{1,6}$';
    ```
- **placed_at** は DB で `DEFAULT now()` を推奨（クライアントは送信しない）。
- **items** は JSONB: `[{ id, name, qty, price }]`（価格・数量は数値で保持）。

---

## 6) 環境変数

- `NEXT_PUBLIC_SUPABASE_URL`
- `NEXT_PUBLIC_SUPABASE_ANON_KEY`
- `NEXT_PUBLIC_STORE_ID` … 注文対象の店舗UUID（ユーザーアプリが参照）

---

## 7) 未解決 / メモ

- `products.image_url` は **存在しない**（必要なら列追加 or フロント側で参照しない）
- 本番RLS: `orders` / `products` を `store_id` 単位＋ロール/ユーザー単位で制限
- Realtime 有効化の再確認: **Database > Replication > Realtime** で `public.orders` の UPDATE を有効

---

## 付録: 便利クエリ

```sql
-- 店舗ごとの商品在庫（在庫>0）
select id, store_id, name, price, stock
from public.products
where store_id = 'YOUR-STORE-UUID' and stock > 0
order by updated_at desc nulls last;

-- 直近の注文
select id, code, customer, total, status, placed_at
from public.orders
where store_id = 'YOUR-STORE-UUID'
order by placed_at desc nulls last
limit 50;

-- 注文の全削除（開発用）
delete from public.orders where store_id = 'YOUR-STORE-UUID';
```

---

## 追記（2025-10-17 JST）

本節は 2025-10-10 版からの**差分・追加**です。既存内容はそのまま残し、変更点のみを追記しています。

### 1) 新規テーブル: `stores`（店舗メタ）

以下の列を持つ `public.stores` を利用します（既存運用に合わせ、自由入力の text カラムで管理）。

```sql
create table if not exists public.stores (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  address text,
  lat double precision,
  lng double precision,
  cover_image_path text,
  current_pickup_slot_no integer,
  tel text,
  url text,
  hours text,
  holiday text,
  category text
);
```

#### チェック制約（形式の緩いバリデーション）
```sql
alter table public.stores
  add constraint if not exists stores_tel_format_chk
    check (tel is null or tel ~ '^\+?[0-9][0-9\-\s\(\)]{6,}$');

alter table public.stores
  add constraint if not exists stores_url_format_chk
    check (url is null or url ~* '^(https?://)');
```

> 備考: TEL/URL は NULL 許容。今回のダミーデータ投入では TEL は一括で `0532-xxx-xxxx` 形式、URL は `https://example.com/store/<hash>` を使用。

---

### 2) RLS（追記）

開発環境の方針に合わせ、`stores` にも全許可ポリシーを適用。

```sql
alter table public.stores enable row level security;

create policy if not exists "dev all stores" on public.stores
  for all using (true) with check (true);
```

---

### 3) 便利クエリ（追記）

```sql
-- 店舗一覧（メタ含む）
select id, name, tel, url, hours, holiday, category
from public.stores
order by name;

-- 任意：ダミーの一括投入（不足分のみ）
with numbered as (
  select id, row_number() over (order by id) rn from public.stores
)
update public.stores s
set
  tel = coalesce(nullif(s.tel,''),
        '0532-' ||
        lpad(((n.rn - 1) / 10000)::text, 3, '0') || '-' ||
        lpad(((n.rn - 1) % 10000)::text, 4, '0')),
  url = coalesce(nullif(s.url,''),
        'https://example.com/store/' || left(md5(cast(s.id as text)), 12))
from numbered n
where s.id = n.id
  and (s.tel is null or s.tel = '' or s.url is null or s.url = '');
```

---

### 4) 差分サマリー（2025-10-10 → 2025-10-17）

- `stores` テーブルを追加（列: `tel`, `url`, `hours`, `holiday`, `category` を含む）
- `stores_tel_format_chk` / `stores_url_format_chk` のチェック制約を追加
- RLS: `stores` に開発用の全許可ポリシーを適用
- 便利クエリに `stores` 取得・ダミー投入クエリを追記

## 追記（2025-10-17 JST・地図埋め込み対応）

### 5) `stores` に地図埋め込み関連カラムを追加

**目的**: 住所検索のズレを解消し、Googleマップの**埋め込み用URL**や**共有URL**、**Place ID**を保存してピンポイント表示する。

#### 追加カラム
- `gmap_embed_src` **text** … `https://www.google.com/maps/embed?pb=...` の**srcだけ**を保存（最優先で利用）
- `gmap_url` **text** … 共有リンク（長い `google.com/maps/...` 推奨。外部で開くボタン用&座標抽出の予備）
- `place_id` **text** … Google Place ID（Embed API + key を使う場合の最精度ルート）

#### DDL（差分）
```sql
-- 1) カラム追加（無ければ追加）
alter table public.stores
  add column if not exists gmap_embed_src text,
  add column if not exists gmap_url text,
  add column if not exists place_id text;

-- 2) 形式チェック（緩めのバリデーション。必要なら調整）
--   gmap_embed_src は "google.com/maps/embed" か、"/maps? ... output=embed" を許可
alter table public.stores
  add constraint if not exists stores_gmap_embed_src_chk
  check (
    gmap_embed_src is null OR
    gmap_embed_src ~* '^https://(www\.)?google\.com/maps/(embed|\?[^#]*\boutput=embed\b)'
  );

--   共有URLは google.com/maps または maps.app.goo.gl を許可（短縮URLは埋め込み不可だが外部遷移に利用）
alter table public.stores
  add constraint if not exists stores_gmap_url_chk
  check (
    gmap_url is null OR
    gmap_url ~* '^https://(www\.)?google\.com/maps/|^https://maps\.app\.goo\.gl/'
  );
```

> 備考: フロント側は `stores` から `gmap_embed_src, gmap_url, place_id` を取得しており、
> `gmap_embed_src` を最優先として埋め込み、無ければ Place ID / 座標 / 住所の順でフォールバックします。

#### 運用ガイド（店舗入力ルール）
- **最優先**: Googleマップ → 共有 → **地図を埋め込む** → HTMLコピー → `<iframe src="…">` の **srcだけ**を `gmap_embed_src` に保存。
  これがあれば**住所ズレなし**で埋め込み表示されます。
- 併せて、外部で開く用に `gmap_url` へ**長いURL（google.com/maps/...）**を保存しておくと◎
  （必要に応じて座標抽出のフォールバックにも利用）
- 将来 Embed API + key を使う場合は `place_id` を保存すると**最精度**で表示可能（任意）。

#### 差分サマリー
- `stores` に `gmap_embed_src`・`gmap_url`・`place_id` を追加（NULL可）  
- 軽い**CHECK制約**で形式をバリデート（`gmap_embed_src` は `google.com/maps/embed` 等に限定）  
- フロントは当該列を参照済（追加のAPI改修は不要）

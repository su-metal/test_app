# 受取時間カットオフ運用メモ（20分版）

このキャンバスは、受取時間（pickup_start / pickup_end）まわりの**現行仕様（2025-10-14時点）**と、**20分カットオフ**の変更手順を運用目線でまとめたものです。いつでも**30分**等に変更できるよう、必要ファイル・コード・SQL・確認観点をひとまとめにしています。

---

## 1. 現行仕様（アプリ側）

- **対象ファイル**
  - `apps/user/src/components/PickupTimeSelector.tsx`
  - `apps/user/src/app/page.tsx`
  - `apps/user/src/lib/supabase.ts`（RLSヘッダ `x-store-id` 固定）

- **動作概要**
  - 店舗側プリセット（`store_pickup_presets`）から当日の候補を生成。
  - **JST 現在時刻 + 20分** 以降のスロットのみ表示（**leadCutoffMin=20**）。
  - 放置中でも**1分ごとに再計算**して過去枠を自動非表示。
  - **近すぎ確認**：開始まで30分未満なら確認ダイアログ（`nearThresholdMin=30`）。
  - カート画面では、未選択だと注文ボタンは **disabled**。
  - 注文ボタン押下時に**最終ガード**（JST現在 + 20分未満ならブロック）。

- **主要プロップス**
  - `leadCutoffMin`（既定 20）… これより近い開始時刻は表示/選択不可。
  - `nearThresholdMin`（既定 30）… これ未満は確認ダイアログ。

---

## 2. 現行仕様（DB側）

- **テーブル/列**
  - `public.orders`
    - `pickup_start TIMESTAMPTZ`
    - `pickup_end   TIMESTAMPTZ`
  - `public.store_pickup_presets`（プリセット本体）
  - `public.stores.current_pickup_slot_no`（1..3）

- **RLS（抜粋）**
  - `store_pickup_presets` は `x-store-id` ヘッダ一致で SELECT 公開。
  - 書込は `authenticated` かつ `x-store-id` 一致のみ許可。

- **最終関門トリガ（導入推奨／20分版）**

```sql
-- 受け取り開始はサーバ時刻の20分以上先を必須にする
CREATE OR REPLACE FUNCTION public.reject_near_or_past_pickup()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
  IF NEW.pickup_start IS NOT NULL
     AND NEW.pickup_start < now() + interval '20 minutes' THEN
    RAISE EXCEPTION 'pickup_start must be at least 20 minutes in the future: %', NEW.pickup_start
      USING ERRCODE = '22007';
  END IF;
  RETURN NEW;
END$$;

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger WHERE tgname='trg_orders_reject_near_or_past_pickup'
  ) THEN
    CREATE TRIGGER trg_orders_reject_near_or_past_pickup
      BEFORE INSERT OR UPDATE OF pickup_start
      ON public.orders
      FOR EACH ROW
      EXECUTE FUNCTION public.reject_near_or_past_pickup();
  END IF;
END$$;
```

> **備考**：DB は UTC 対応だが `timestamptz` 比較で問題なし。JST で `+09:00` を付けて保存すれば OK。

---

## 3. 値を変更したいとき（例：20 → 30 分）

### A) フロント側（即時反映）

- **`PickupTimeSelector.tsx` 呼び出し側**（カート内）：

```tsx
<PickupTimeSelector
  storeId={sid}
  value={pickupByShop[sid] ?? null}
  onSelect={(slot) => setPickupByShop(prev => ({ ...prev, [sid]: slot }))}
  leadCutoffMin={30}        // ★ ここを変更（省略時は20）
  nearThresholdMin={30}     // 確認ダイアログの閾値（任意）
/>
```

- **`page.tsx` の最終ガード**：

```tsx
const LEAD_CUTOFF_MIN = 30; // ★ ここを変更
...
if (startMin < nowMin + LEAD_CUTOFF_MIN) {
  alert(`受け取り開始まで${Math.max(0, startMin - nowMin)}分です。直近枠は選べません（${LEAD_CUTOFF_MIN}分前まで）。`);
  return;
}
```

> **推奨**：プロジェクトで統一するため、`LEAD_CUTOFF_MIN` を 1 か所の設定値として参照させると事故が減ります。

### B) DB側（絶対ルール）

- **SQL の interval を変更して再実行**

```sql
CREATE OR REPLACE FUNCTION public.reject_near_or_past_pickup()
RETURNS TRIGGER LANGUAGE plpgsql AS $$
BEGIN
  IF NEW.pickup_start IS NOT NULL
     AND NEW.pickup_start < now() + interval '30 minutes' THEN -- ★ 20→30
    RAISE EXCEPTION 'pickup_start must be at least 30 minutes in the future: %', NEW.pickup_start;
  END IF;
  RETURN NEW;
END$$;
```

> すでにトリガが存在するため **CREATE TRIGGER は不要**（関数の `OR REPLACE` のみで切替）。

---

## 4. 運用・緊急対応（停止/復旧/削除）

- **一時停止**（新規注文の保存のみ緩めたい場合）

```sql
ALTER TABLE public.orders DISABLE TRIGGER trg_orders_reject_near_or_past_pickup;
```

- **再有効化**

```sql
ALTER TABLE public.orders ENABLE TRIGGER trg_orders_reject_near_or_past_pickup;
```

- **完全削除**（ルール撤廃）

```sql
DROP TRIGGER IF EXISTS trg_orders_reject_near_or_past_pickup ON public.orders;
DROP FUNCTION IF EXISTS public.reject_near_or_past_pickup();
```

---

## 5. 確認チェックリスト（変更時）

1. **フロント**の `leadCutoffMin` / `LEAD_CUTOFF_MIN` を意図値に変更。
2. **DB の関数** `reject_near_or_past_pickup()` の interval を同じ値に変更し、`CREATE OR REPLACE` を実行。
3. ステージングで：
   - カットオフより**手前**の枠が**表示/選択不可**になっているか。
   - カットオフ直後（例：31分後）が**選択可能**で、30分未満は**不可**か。
   - 注文押下時の**最終ガード**が機能するか。
   - DB 直接 INSERT/UPDATE に対し、関数が正しく例外を投げるか。

---

## 6. 仕様（要点）

- 受取時間は **当日**の `TIMESTAMPTZ` として保存（`+09:00` を明示）。
- 表示候補は **JST 現在 + leadCutoffMin（既定20分）** 以降のみ。
- 30分未満は**確認ダイアログ**を表示（`nearThresholdMin`）。
- カート画面での未選択は**ボタン無効化**。
- 注文押下時に**再検証**（直前ガード）。
- DB トリガで**最終関門**（カットオフ未満を拒否）。

---

## 7. よくある質問（FAQ）

- **Q. 端末時計がズレているとどうなる？**
  - A. フロントの挙動は多少影響するが、**DB トリガが最終的に正す**ため不整合は保存されません。

- **Q. 店舗ごとにカットオフを変えたい**
  - A. まずは固定運用が安全。強い要望が出たら `stores` に `lead_cutoff_min` を追加 → フロント props と DB 関数で参照する設計に拡張可能。

- **Q. 祝日/曜日別の帯を使いたい**
  - A. 現行は **当日一律** 設計。将来、`store_pickup_presets` を曜日別に複数持たせる拡張が可能。

---

## 8. 参考実装（JST ISO 生成：保存時）

```ts
// "HH:MM" を当日の JST ISO (+09:00) に変換
const toTodayJstISO = (hhmm: string) => {
  const now = new Date();
  const yyyy = now.getFullYear();
  const mm = String(now.getMonth() + 1).padStart(2, "0");
  const dd = String(now.getDate()).padStart(2, "0");
  return `${yyyy}-${mm}-${dd}T${hhmm}:00+09:00`;
};

// 例：選択されたピル（{start,end}）を orders に保存
const startIso = toTodayJstISO(selected.start);
const endIso   = toTodayJstISO(selected.end);
await supabase.from("orders").update({ pickup_start: startIso, pickup_end: endIso }).eq("id", orderId);
```

---

### 最後に
- **カットオフ値の変更**はこのキャンバスの「3. 値を変更したいとき」を見ればすぐ対応可能です。
- 本番切替は **フロント → DB 関数の順**で（短時間の不整合を避けるため）。


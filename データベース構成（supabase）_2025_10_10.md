# 現在のデータベース構成（Supabase）

> プロジェクト: アプリ作成 / 環境: 開発（Anon Key, RLS: 開発用全許可）
> 日付: 2025-10-10（JST）

---

## 1) テーブル概要

### products（商品）
- **確認済みの列**（ログ・実装より）
  - `id` **uuid** (PK)
  - `store_id` **uuid** (NOT NULL)
  - `name` **text**
  - `price` **numeric**
  - `stock` **integer**
  - `updated_at` **timestamptz**
- **存在しない列（ログで 400 を確認）**
  - `image_url` は **存在しない**（Select での 400: `column products.image_url does not exist`）
- **推奨インデックス**
  - `create index if not exists idx_products_store_id on public.products(store_id);`
  - `create index if not exists idx_products_store_id_stock on public.products(store_id, stock);`

---

### orders（注文）
- **確認済みの列/仕様**（実装・運用より）
  - `id` **uuid** (PK)
  - `store_id` **uuid** (NOT NULL)
  - `code` **text**  … ユーザー側の **6桁コード**（"000123" 形式）※UIは**完全一致**で照合
  - `customer` **text**  … メール等
  - `items` **jsonb**  … `[{ id, name, qty, price }]`
  - `total` **numeric**  … 合計（数値）
  - `placed_at` **timestamptz**  … 注文時刻（DB `DEFAULT now()` を**推奨**）
  - `status` **text**  … 実運用は `PENDING` / `FULFILLED`（UIでは `FULFILLED → redeemed` として表示）
- **推奨インデックス**
  - `create index if not exists idx_orders_store_id on public.orders(store_id);`
  - `create index if not exists idx_orders_status on public.orders(status);`
  - `create index if not exists idx_orders_code on public.orders(code);`

> 注: `status` は Supabase UI で **PENDING / FULFILLED** の選択肢が見える状態。`REDEEMED` はDB上の値としては**不要**（UI側が FULFILLED を redeemed と扱う）。

---

## 2) 代表的なDDL（現状整合 & 推奨を併記）

```sql
-- products（既存）
create table if not exists public.products (
  id uuid primary key default gen_random_uuid(),
  store_id uuid not null,
  name text,
  price numeric,
  stock integer,
  updated_at timestamptz default now()
);

-- orders（既存＋推奨DEFAULT）
create table if not exists public.orders (
  id uuid primary key default gen_random_uuid(),
  store_id uuid not null,
  code text,                 -- 6桁の文字列（例 "012345"）
  customer text,
  items jsonb,               -- [{id,name,qty,price}]
  total numeric,
  placed_at timestamptz default now(),  -- ★推奨: DEFAULT now()
  status text                 -- 運用: PENDING / FULFILLED
);

-- 参考: status を厳格化したい場合（任意）
-- alter table public.orders
--   add constraint orders_status_chk check (status in ('PENDING','FULFILLED'));
```

---

## 3) RLS（Row Level Security）

開発中は **全許可**で運用中。

```sql
alter table public.products enable row level security;
alter table public.orders   enable row level security;

-- products: 開発用
create policy if not exists "dev all products" on public.products
for all using (true) with check (true);

-- orders: 開発用（select / insert / update / delete）
create policy if not exists "dev select orders" on public.orders  for select using (true);
create policy if not exists "dev insert orders" on public.orders  for insert with check (true);
create policy if not exists "dev update orders" on public.orders  for update using (true) with check (true);
create policy if not exists "dev delete orders" on public.orders  for delete using (true);
```

> 本番では `store_id` や認証クレームでスコープを絞ること（例: `store_id = auth.jwt() ->> 'store_id'`）。

---

## 4) Realtime（購読）

- 対象: `public.orders`
- イベント: **UPDATE（必須）**, INSERT（任意）
- RLSの **SELECT ポリシーが必要**（SELECT不可だとUPDATE通知も届かない）
- ユーザーアプリ:
  - `status` が `FULFILLED` に更新されたUPDATEを受け取り、ローカル `orders` の該当行を `redeemed` に更新
  - 照合キーは **`code` の6桁完全一致**（一致しない場合のみ `id` で保険）
  - UI は `code6` 完全一致で重複除去し、`redeemed` を優先

---

## 5) データ整合の運用要点

- **orders.code** は **6桁の数字文字列**で統一（先頭ゼロ保持）。
  - 既存データに数値（ゼロ欠落）がある場合は一度だけ正規化:
    ```sql
    alter table public.orders alter column code type text using code::text;
    update public.orders
      set code = lpad(regexp_replace(code, '\\D', '', 'g'), 6, '0')
      where code ~ '^\d{1,6}$';
    ```
- **placed_at** は DB で `DEFAULT now()` を推奨（クライアントは送信しない）。
- **items** は JSONB: `[{ id, name, qty, price }]`（価格・数量は数値で保持）。

---

## 6) 環境変数

- `NEXT_PUBLIC_SUPABASE_URL`
- `NEXT_PUBLIC_SUPABASE_ANON_KEY`
- `NEXT_PUBLIC_STORE_ID` … 注文対象の店舗UUID（ユーザーアプリが参照）

---

## 7) 未解決 / メモ

- `products.image_url` は **存在しない**（必要なら列追加 or フロント側で参照しない）
- 本番RLS: `orders` / `products` を `store_id` 単位＋ロール/ユーザー単位で制限
- Realtime 有効化の再確認: **Database > Replication > Realtime** で `public.orders` の UPDATE を有効

---

## 付録: 便利クエリ

```sql
-- 店舗ごとの商品在庫（在庫>0）
select id, store_id, name, price, stock
from public.products
where store_id = 'YOUR-STORE-UUID' and stock > 0
order by updated_at desc nulls last;

-- 直近の注文
select id, code, customer, total, status, placed_at
from public.orders
where store_id = 'YOUR-STORE-UUID'
order by placed_at desc nulls last
limit 50;

-- 注文の全削除（開発用）
delete from public.orders where store_id = 'YOUR-STORE-UUID';
```

